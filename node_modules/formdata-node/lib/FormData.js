"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toStringTag = _interopRequireDefault(require("@babel/runtime/core-js/symbol/to-string-tag"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _map = _interopRequireDefault(require("@babel/runtime/core-js/map"));

var _symbol = _interopRequireDefault(require("@babel/runtime/core-js/symbol"));

var _iterator = _interopRequireDefault(require("@babel/runtime/core-js/symbol/iterator"));

var _from = _interopRequireDefault(require("@babel/runtime/core-js/array/from"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _wrapAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapAsyncGenerator"));

var _awaitAsyncGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/awaitAsyncGenerator"));

var _asyncIterator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncIterator"));

var _asyncGeneratorDelegate2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncGeneratorDelegate"));

var _stream = _interopRequireDefault(require("stream"));

var _path = _interopRequireDefault(require("path"));

var _invariant = _interopRequireDefault(require("@octetstream/invariant"));

var _mimeTypes = _interopRequireDefault(require("mime-types"));

var _promiseFs = _interopRequireDefault(require("promise-fs"));

var _bind = _interopRequireDefault(require("./util/bind"));

var _concat = _interopRequireDefault(require("./util/concat"));

var _boundary = _interopRequireDefault(require("./util/boundary"));

var _getType = _interopRequireDefault(require("./util/getType"));

var _isString = _interopRequireDefault(require("./util/isString"));

var _isObject = _interopRequireDefault(require("./util/isObject"));

var _isBuffer = _interopRequireDefault(require("./util/isBuffer"));

var _isStream = _interopRequireDefault(require("./util/isStream"));

var _isFunction = _interopRequireDefault(require("./util/isFunction"));

var _isReadStream = _interopRequireDefault(require("./util/isReadStream"));

var _StreamIterator = _interopRequireDefault(require("./util/StreamIterator"));

const isArray = Array.isArray;
/**
 * FormData implementation for Node.js environments.
 * Bult over Readable stream and async generators.
 * Can be used to communicate between servers with multipart/form-data format.
 *
 * @api public
 */

var _Symbol$toStringTag = _toStringTag.default;
var _Symbol$iterator = _iterator.default;
var _Symbol$asyncIterator = _symbol.default.asyncIterator;

class FormData {
  /**
   * Check if given value is instance of FormData
   * Note: This method is not a part of client-side FormData interface.
   *
   * @param {any} value
   *
   * @return {boolean}
   *
   * @public
   */
  static isFormData(value) {
    return value instanceof FormData;
  }
  /**
   * @param {array} fields – an optional FormData initial fields.
   *   Each initial field should be passed as a collection of the objects
   *   with "name", "value" and "filename" props.
   *   See the FormData#append for more info about the available format.
   */


  constructor(_fields = null) {
    (0, _defineProperty2.default)(this, "__getMime", filename => _mimeTypes.default.lookup(filename) || this.__defaultContentType);
    (0, _defineProperty2.default)(this, "__getFooter", () => (0, _concat.default)([this.__dashes, this.__boundary, this.__dashes, this.__carriage.repeat(2)]));
    (0, _defineProperty2.default)(this, "__read", () => {
      const onFulfilled = ({
        done,
        value
      }) => {
        if (done) {
          return this.__stream.push(null);
        }

        this.__stream.push((0, _isBuffer.default)(value) ? value : Buffer.from(String(value)));
      };

      const onRejected = err => this.__stream.emit("error", err);

      this.__curr.next().then(onFulfilled).catch(onRejected);
    });
    (0, _defineProperty2.default)(this, "__appendFromInitialFields", fields => {
      for (const field of fields) {
        if ((0, _isObject.default)(field)) {
          this.append(field.name, field.value, field.filename);
        }
      }
    });
    (0, _defineProperty2.default)(this, "append", (name, value, filename) => this.__setField(name, value, filename, 1));
    (0, _defineProperty2.default)(this, "set", (name, value, filename) => this.__setField(name, value, filename));
    (0, _defineProperty2.default)(this, "has", name => this.__content.has(name));
    (0, _defineProperty2.default)(this, "get", name => {
      const field = this.__content.get(name);

      if (!field) {
        return undefined;
      }

      return field.values[0];
    });
    (0, _defineProperty2.default)(this, "getAll", name => {
      const field = this.__content.get(name);

      return field ? (0, _from.default)(field.values) : [];
    });
    (0, _defineProperty2.default)(this, "delete", name => void this.__content.delete(name));
    (0, _defineProperty2.default)(this, "forEach", (fn, ctx = null) => {
      for (const [name, value] of this) {
        fn.call(ctx, value, name, this);
      }
    });
    (0, _bind.default)([_iterator.default, _symbol.default.asyncIterator, "toString", "inspect", "keys", "values", "entries"], this);
    this.__carriage = "\r\n";
    this.__defaultContentType = "application/octet-steam";
    this.__dashes = "--";
    this.__boundary = (0, _concat.default)(["NodeJSFormDataStream", (0, _boundary.default)()]);
    this.__content = new _map.default();
    this.__curr = this.__getField();
    this.__stream = new _stream.default.Readable({
      read: this.__read
    });

    if (isArray(_fields)) {
      this.__appendFromInitialFields(_fields);
    }
  }
  /**
   * @private
   */


  /**
   * @private
   */
  __getHeader(name, filename) {
    const head = [this.__dashes, this.__boundary, this.__carriage, "Content-Disposition: form-data; ", `name="${name}"`];

    if (filename) {
      head.push(`; filename="${filename}"${this.__carriage}`);
      head.push(`Content-Type: "${this.__getMime(filename)}"`);
    }

    head.push(this.__carriage.repeat(2));
    return (0, _concat.default)(head);
  }
  /**
   * @private
   */


  /**
   * Get each field from internal Map
   *
   * @private
   */
  __getField() {
    var _this = this;

    return (0, _wrapAsyncGenerator2.default)(function* () {
      for (const [name, {
        values,
        filename
      }] of _this.__content) {
        // Set field header
        yield _this.__getHeader(name, filename);

        for (const value of values) {
          if ((0, _isStream.default)(value)) {
            // Read the stream content
            yield* (0, _asyncGeneratorDelegate2.default)((0, _asyncIterator2.default)((0, _isFunction.default)(value[_symbol.default.asyncIterator]) ? value : new _StreamIterator.default(value)), _awaitAsyncGenerator2.default);
          } else {
            yield value;
          }
        } // Add trailing carriage


        yield _this.__carriage;
      } // Add a footer when all fields ended


      yield _this.__getFooter();
    })();
  }
  /**
   * Read values from internal storage and push it to the internal stream
   *
   * @return {void}
   *
   * @private
   */


  /**
   * Appends a new value onto an existing key inside a FormData object,
   * or adds the key if it does not already exist.
   *
   * @param {string} name – The name of the field whose data
   *   is contained in value
   *
   * @param {any} value – The field value. You can pass any primitive type
   *   (including null and undefined), Buffer or Readable stream.
   *   Note that Arrays and Object will be converted to string
   *   by using String function.
   *
   * @param {string} [filename = undefined] A filename of given field.
   *   Can be added only for Buffer and Readable
   *
   * @return {void}
   *
   * @private
   */
  __setField(name, value, filename, append = false) {
    (0, _invariant.default)(!(0, _isString.default)(name), TypeError, "Field name should be a string. Received %s", (0, _getType.default)(name));
    (0, _invariant.default)(filename && !(0, _isString.default)(filename), TypeError, "Filename should be a string (if passed). Received %s", (0, _getType.default)(filename)); // Getting a filename for Buffer and Readable values

    if ((0, _isBuffer.default)(value) && filename) {
      filename = _path.default.basename(filename);
    } else if ((0, _isStream.default)(value) && (value.path || filename)) {
      // Readable stream which created from fs.createReadStream
      // have a "path" property. So, we can get a "filename"
      // from the stream itself.
      filename = _path.default.basename(value.path || filename);
    } else {
      // The regular values shouldn't have "filename" property
      filename = undefined;
    }

    append = Boolean(append);

    if (!((0, _isStream.default)(value) || (0, _isBuffer.default)(value))) {
      value = String(value);
    }

    const field = this.__content.get(name); // Set a new field if given name is not exists


    if (!field) {
      return void this.__content.set(name, {
        append,
        filename,
        values: [value]
      });
    } // Replace a value of the existing field if "set" called


    if (!append) {
      return void this.__content.set(name, {
        append,
        filename,
        values: [value]
      });
    } // Do nothing if the field has been created from .set()


    if (!field.append) {
      return undefined;
    } // Append a new value to the existing field


    field.values.push(value);

    this.__content.set(name, field);
  }
  /**
   * Returns boundary string
   *
   * @return {string}
   *
   * @public
   */


  get boundary() {
    return this.__boundary;
  }
  /**
   * Returns headers for multipart/form-data
   */


  get headers() {
    return {
      "Content-Type": (0, _concat.default)(["multipart/form-data; ", "boundary=", this.boundary])
    };
  }
  /**
   * Returns the internal stream
   *
   * @return {stream.Readable}
   *
   * @public
   */


  get stream() {
    return this.__stream;
  }
  /**
   * Returns computed length of the FormData content.
   * If data contains stream.Readable field(s),
   * the method will always return 0.
   *
   * @return {number}
   */


  getComputedLength() {
    var _this2 = this;

    return (0, _asyncToGenerator2.default)(function* () {
      if (_this2.__content.size === 0) {
        return 0;
      }

      let length = 0;
      const carriageLength = Buffer.from(_this2.__carriage).length;

      for (const [name, {
        filename,
        values
      }] of _this2.__content) {
        length += Buffer.from(_this2.__getHeader(name, filename)).length;

        for (const value of values) {
          if ((0, _isStream.default)(value)) {
            if (!(0, _isReadStream.default)(value)) {
              return undefined;
            }

            length += yield _promiseFs.default.stat(value.path).then(({
              size
            }) => size);
          } else if ((0, _isBuffer.default)(value)) {
            length += value.length;
          } else {
            length += Buffer.from(value).length;
          }
        }

        length += carriageLength;
      }

      length += Buffer.from(_this2.__getFooter()).length;
      return length;
    })();
  }
  /**
   * Appends a new value onto an existing key inside a FormData object,
   * or adds the key if it does not already exist.
   *
   * @param {string} name – The name of the field whose data
   *   is contained in value
   *
   * @param {any} value – The field value. You can pass any primitive type
   *   (including null and undefined), Buffer or Readable stream.
   *   Note that Arrays and Object will be converted to string
   *   by using String function.
   *
   * @param {string} [filename = undefined] A filename of given field.
   *   Can be added only for Buffer and Readable
   *
   * @return {void}
   *
   * @public
   */


  /**
   * Returns a string representation of the FormData
   *
   * @return {string}
   */
  toString() {
    return "[object FormData]";
  }
  /**
   * Returns a string representation of the FormData
   *
   * @return {string}
   */


  inspect() {
    return "FormData";
  }

  get [_Symbol$toStringTag]() {
    return "FormData";
  }
  /**
   * @return {IterableIterator<string>}
   */


  *keys() {
    for (const key of this.__content.keys()) {
      yield key;
    }
  }
  /**
   * @return {IterableIterator<[string, any]>}
   */


  *entries() {
    for (const name of this.keys()) {
      const values = this.getAll(name); // Yield each value of a field, like browser-side FormData does.

      for (const value of values) {
        yield [name, value];
      }
    }
  }
  /**
   * @return {IterableIterator<any>}
   */


  *values() {
    for (const [, values] of this) {
      yield values;
    }
  }
  /**
   * Executes a given callback for each field of the FormData instance
   *
   * @param {function} fn – Function to execute for each element,
   *   taking three arguments:
   *     + {any} value – A value(s) of the current field.
   *     + {string} – Name of the current field.
   *     + {FormData} fd – The FormData instance that forEach
   *       is being applied to
   *
   * @param {any} [ctx = null]
   *
   * @public
   */


  /**
   * @return {IterableIterator<[string, any]>}
   */
  [_Symbol$iterator]() {
    return this.entries();
  }
  /**
   * This method allows to read a content from internal stream
   * using async generators and for-await-of APIs
   *
   * @return {IterableIterator<Promise<Buffer>>}
   *
   * @public
   */


  [_Symbol$asyncIterator]() {
    if ((0, _isFunction.default)(this.stream[_symbol.default.asyncIterator])) {
      return this.stream[_symbol.default.asyncIterator]();
    }

    return new _StreamIterator.default(this.stream);
  }

}

var _default = FormData;
exports.default = _default;